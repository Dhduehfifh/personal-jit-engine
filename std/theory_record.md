# Uranium JIT 引擎完整理论与数据结构梳理

## 一、总体设计目标

构建一个极致高性能、极致可控的 JIT 执行引擎系统，支持如下核心目标：

* 支持热区函数与冷区函数分离调度，极致降低跳转延迟；
* 支持基于 ASCII 指令码的跳转与解释执行；
* 支持嵌入式结构化数据传输（类 JSON）并结合指令流统一解析；
* 所有跳转结构由汇编主控，调度逻辑通过页表（page table）配置实现；
* 支持宏更新、指令绑定、函数热替换、快照导出等功能。

---

## 二、指令结构设计（ASCII 驱动模型）

### 1. ASCII 区段划分

| 区段类型  | 范围            | 说明                         |
| ----- | ------------- | -------------------------- |
| 控制指令  | `0x00~0x1F`   | 分配给 JIT 指令（如 ADD、SUB、CALL） |
| 数据立即数 | `0x30~0x39`   | 字符 `'0'`\~`'9'` 直接转换为整数    |
| 标识符   | `A~Z, a~z`    | 表示变量名、寄存器名、函数名等            |
| 字符串段  | `"` 包围        | 表示一段数据字段，进入结构数据解释模式        |
| 特殊字符  | `, { } ( )` 等 | 用于分隔参数、表达式或子函数             |

### 2. 解释逻辑状态机

| 状态        | 输入            | 状态转移      | 处理逻辑                  |
| --------- | ------------- | --------- | --------------------- |
| 默认        | `\x00~\x1F`   | opcode 模式 | 查找 dispatch 表并调用      |
| 默认        | `"`           | string 模式 | 缓存 string 内容直到 `"` 结束 |
| 默认        | `0~9`         | 数据模式      | 解析为立即数放入 arg 缓冲区      |
| 默认        | `A~Z` / `a~z` | 标识符模式     | 查 symbol 表替换为寄存器/地址   |
| string 模式 | `"`           | 默认        | 将字符串写入内存区             |

---

## 三、页表系统设计（Page Table）

### 1. 页结构

```c
typedef struct {
  uint8_t ascii;                   // 对应 ASCII 字符
  enum { FUNC, DATA, STRING } type; // 类型
  void (*handler)(void);          // 函数指针（仅 FUNC）
  const char* description;        // 调试用描述
} PageEntry;
```

### 2. 全局跳表示例

```c
PageEntry ascii_pages[128] = {
  [0x01] = {0x01, FUNC, jit_add, "ADD x0, x1"},
  [0x02] = {0x02, FUNC, jit_sub, "SUB x0, x1"},
  ['A']  = {'A',  DATA, NULL, "register A"},
  ['"']  = {'"', STRING, NULL, "start string mode"},
};
```

---

## 四、热区与冷区内存管理

### 1. 热区（Hot Exec Area）

* 用 `mmap(PROT_EXEC)` 分配一块可执行内存；
* 所有函数跳板（jump trampoline）放在此处；
* 每个跳板负责：`ldr x16, =handler_addr; br x16` 跳入真实函数；

### 2. 冷区（Code/Data Pool）

* 存储所有真实的业务逻辑实现；
* 被热区跳板调用；
* 冷区地址保持固定，可随时被跳板覆盖。

---

## 五、结构化数据线（JSON-like Memory Line）

### 1. 基本格式

* 数据使用 `"key":value` 方式组织；
* 多字段间使用 `,` 分隔；
* 所有数据不换行，直接拼接为线性字节流；

### 2. 示例

```
"id":123,"type":"add","args":[1,2],"ret":3
```

### 3. 存储方式

* 每个字段以结构体映射存储：

```c
typedef struct {
    const char* key;
    union { int i; const char* str; } value;
    enum { INT, STR, ARRAY } type;
} KV;
```

* 整体数组拼接：

```c
KV frame[] = {
  {"id", 123, INT},
  {"type", "add", STR},
  {"args", "[1,2]", STR},
  {"ret", 3, INT}
};
```

* 转为字符流存入 `char linear_buffer[1024];`

---

## 六、调度与执行过程

1. 输入：一串 ASCII 字节码（指令+数据混合）
2. 解释器状态机逐个字节读取，更新状态；
3. opcode 执行跳转，调用 handler；
4. 参数缓冲区从 ASCII 数据中取出；
5. 结构化字段写入结果缓冲区或导出快照。

---

## 七、补充：优势总结

| 特性     | 描述                          |
| ------ | --------------------------- |
| 极致轻量   | 1 字节即代表指令，天然支持压缩执行流         |
| 高动态性   | opcode 与 handler 绑定可动态更新或替换 |
| 内存布局统一 | 数据与逻辑共用线性区，可视化更易构建          |
| 可热更新   | 热区跳板重定向即可完成函数热更新            |
| 可导出    | 所有状态快照可结构化导出为 `.json` 或映射表  |

---

## 八、后续可拓展

* 支持高位 ASCII 进行模块扩展（如 `0x80~0xFF` 为插件指令）
* 支持跨核心（多页）调用：页表 ID + opcode 二维组合
* 支持 hardware ABI 绑定：页结构绑定寄存器方案或 I/O
* 支持 JIT macro：如 `@define_func("A", handler_x)` 生成跳板
